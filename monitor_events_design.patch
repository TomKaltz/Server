--- a/src/core/monitor/monitor.h
+++ b/src/core/monitor/monitor.h
@@ -31,6 +31,23 @@
 
 namespace caspar { namespace core { namespace monitor {
 
+// Event-based monitoring for immediate notifications
+struct event 
+{
+    std::string path;        // e.g. "/channel/1/stage/layer/10"
+    std::string type;        // e.g. "cleared", "loaded", "finished"
+    vector_t    data;        // optional additional data
+    uint64_t    timestamp;   // when the event occurred
+    
+    event(const std::string& path, const std::string& type, vector_t data = {})
+        : path(path), type(type), data(std::move(data)), timestamp(std::chrono::steady_clock::now().time_since_epoch().count())
+    {
+    }
+};
+
+using event_handler_t = std::function<void(const event&)>;
+static event_handler_t global_event_handler = nullptr;
+
 using data_t = boost::
     variant<bool, std::int32_t, std::int64_t, std::uint32_t, std::uint64_t, float, double, std::string, std::wstring>;
 using vector_t   = boost::container::small_vector<data_t, 2>;
@@ -120,6 +137,16 @@ class state
     data_map_t::const_iterator end() const { return data_.end(); }
 };
 
+// Global functions for event-based monitoring
+inline void set_event_handler(event_handler_t handler) 
+{
+    global_event_handler = std::move(handler);
+}
+
+inline void send_event(const event& evt) 
+{
+    if (global_event_handler) global_event_handler(evt);
+}
+
 }}} // namespace caspar::core::monitor

--- a/src/core/producer/stage.cpp
+++ b/src/core/producer/stage.cpp
@@ -320,7 +320,12 @@ struct stage::impl : public std::enable_shared_from_this<impl>
 
     std::future<void> clear(int index)
     {
-        return executor_.begin_invoke([=] { layers_.erase(index); });
+        return executor_.begin_invoke([=] {
+            if (layers_.find(index) != layers_.end()) {
+                monitor::send_event(monitor::event("/channel/" + std::to_string(channel_index_) + "/stage/layer/" + std::to_string(index), "cleared"));
+            }
+            layers_.erase(index);
+        });
     }
 
     std::future<void> clear()
@@ -346,6 +351,12 @@ struct stage::impl : public std::enable_shared_from_this<impl>
     std::future<void> clear()
     {
-        return executor_.begin_invoke([=] { layers_.clear(); });
+        return executor_.begin_invoke([=] {
+            for (auto& p : layers_) {
+                monitor::send_event(monitor::event("/channel/" + std::to_string(channel_index_) + "/stage/layer/" + std::to_string(p.first), "cleared"));
+            }
+            layers_.clear();
+        });
     }
 
     std::future<void> swap_layers(const std::shared_ptr<stage>& other, bool swap_transforms)

--- a/src/core/producer/layer.cpp
+++ b/src/core/producer/layer.cpp
@@ -56,6 +56,7 @@ struct layer::impl
         background_ = std::move(producer);
         auto_play_  = auto_play;
 
+        // Could send "loaded" event here if we want to track loads too
         if (auto_play_ && foreground_ == frame_producer::empty()) {
             play();
         } else if (preview_producer) {
@@ -98,6 +99,7 @@ struct layer::impl
     void stop()
     {
         foreground_ = frame_producer::empty();
+        // Could send "stopped" event here
         auto_play_  = false;
     }

--- a/src/protocol/osc/client.cpp
+++ b/src/protocol/osc/client.cpp
@@ -26,6 +26,7 @@
 
 #include "oscpack/OscOutboundPacketStream.h"
 
+#include <core/monitor/monitor.h>
 #include <common/endian.h>
 #include <common/utf.h>
 
@@ -220,6 +221,25 @@ struct client::impl : public spl::enable_shared_from_this<client::impl>
         });
         cond_.notify_all();
     }
+    
+    void send_event(const core::monitor::event& evt)
+    {
+        std::vector<udp::endpoint> endpoints;
+        {
+            std::lock_guard<std::mutex> lock(mutex_);
+            for (auto& p : reference_counts_by_endpoint_) {
+                endpoints.push_back(p.first);
+            }
+        }
+        
+        if (!endpoints.empty()) {
+            ::osc::OutboundPacketStream o(reinterpret_cast<char*>(buffer_.data()), static_cast<unsigned long>(buffer_.size()));
+            o << ::osc::BeginMessage(evt.path.c_str()) << evt.type.c_str() << static_cast<int64_t>(evt.timestamp) << ::osc::EndMessage;
+            
+            for (const auto& endpoint : endpoints) {
+                socket_.send_to(boost::asio::buffer(o.Data(), o.Size()), endpoint);
+            }
+        }
+    }
 };
 
 client::client(std::shared_ptr<boost::asio::io_context> service)
@@ -243,6 +263,11 @@ std::shared_ptr<void> client::get_subscription_token(const boost::asio::ip::udp
 
 void client::send(const core::monitor::state& state) { impl_->send(state); }
 
+void client::send_event(const core::monitor::event& evt) { impl_->send_event(evt); }
+
+// Set up the global event handler to forward to OSC
+// This would be called during initialization
+// core::monitor::set_event_handler([this](const auto& evt) { this->send_event(evt); });
+
 }}} // namespace caspar::protocol::osc